\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
%\usepackage{polski}
\usepackage{textcomp}
\usepackage{color}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{amsthm}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
    language=Bash,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    breaklines=true,
    breakatwhitespace=true,
    escapeinside={(*}{*)},          % if you want to add LaTeX within your code
    tabsize=4
}

\title{Notes from Semantics and verification of programs}
\author{Jacek Olczyk}
\date{October 2018}

\begin{document}
\maketitle
\part{Notes from tutorials by Lorenzo Clemente}
\section{Small step semantics - continuation}
\subsection{Recap}
\begin{itemize}
	\item Global environments $ \rho \vdash e \rightarrow e' $
	\item $\frac{\rho[x\rightarrow n]\vdash e \rightarrow e' }{
		 \rho\vdash\text{ let } x= \underline{n}\text{ in }e \rightarrow\text{ let }x = \underline{n}\text{ in }e'}$
\end{itemize}
\subsection{Local environments}
\begin{itemize}
	\item How do we define the semantics for 'let $x$ = $e$ in $f$' expressions using local environments? More precisely, we need $e$ to have its own environment, so that its evaluation doesn't affect the environment of $f$, as is the case with global environments.
	\item We are given the following 2 rules:
	\item $\frac{}{ (\rho, x)\rightarrow(\rho, \rho(x)) }$
	\item $\frac{}{(\rho, \text{ let }x = \underline{n}\text{ in }e)\rightarrow(\rho[x\rightarrow n], e) }$
	\item Now we need to give a rule for evaluating let expressions where a non-numeric expression is assigned to $x$.
	\item $\frac{ (\rho, e)\rightarrow(\rho', e') }
	{ (\rho, \text{ let }x = e\text{ in }f)\rightarrow((\rho?\text{ or maybe }\rho'?), \text{ let } x = e'\text{ in }f) }$
	\item $ \rho $ doesn't work, because then a nested let in expression can't change the value of their variables.
	\item Neither does $ \rho' $, because then we don't get our original environment back at the end.
	\item Solution: new construct
	\item $ e \text{ then }x=n $
	\item Now we have:
	\item $\frac{ (\rho, e)\rightarrow(\rho', e') }
	{ (\rho, e\text{ then }x = \underline{n})\rightarrow(\rho', e'\text{ then } x=\underline{n}) }$
	\item $\frac{}{ (\rho, \underline m\text{ then }x=\underline{n})\rightarrow(\rho[x\rightarrow \underline{n}], \underline{m}) }$
	\item $\frac{}{(\rho, \text{ let }x = \underline{n}\text{ in }e)\rightarrow(\rho[x\rightarrow \underline{n}], e\text{ then }x=\rho(x)) }$
\end{itemize}
\section{Imperative language}
\begin{itemize}
	\item Syntax
\item $C::=\text{ Skip }| X:=e|C;C|\text{if }b\text{ then }c\text{ else }c |\text{while }b\text{ do }c$
\item $e::= n|x|e+e$
\item $b::true|false|e\leq e|\neg b | b\wedge b$
\item $ E[[e]]_{s}\in\mathbb{Q} $, $ B[[b]]_{s}\in\{true, false\} $
\item $ s\in State = Var\rightarrow \mathbb{Q} $
\item Configurations
\item $ (c, s)\in C $
\item $ s\in C$ (final) 
\item Small step rules for C - expressions
\item $\frac{}{(Skip, s)\rightarrow s}$
\item $\frac{}{(x:=e, s)\rightarrow s[x\rightarrow E[[e]]_{s}}$
\item $\frac{(c, s)\rightarrow s'}{(c;d, s)\rightarrow (d, s')}$
\item $\frac{(c, s)\rightarrow (c', s')}{(c;d, s)\rightarrow (c';d, s')}$
\item $\frac{B[[b]]_{s}=true}{(\text{if }b\text{ then }c\text{ else }d , s)\rightarrow (c, s)}$
\item $\frac{B[[b]]_{s}=false}{(\text{if }b\text{ then }c\text{ else }d , s)\rightarrow (d, s)}$
\item $\frac{B[[b]]_{s}=true}{(\text{while }b\text{ do }c, s)\rightarrow (c; \text{while }b\text{ do }c, s)}$
\item $\frac{B[[b]]_{s}=false}{(\text{while }b\text{ do }c , s)\rightarrow s}$
\item Adding "Repeat c until b"
\item $\frac{}{(\text{Repeat }c\text{ until }b, s)\rightarrow (c ; \text{if }b\text{ then }Skip\text{ else }\text{Repeat }c\text{ until }b, s)}$
\end{itemize}
\section{Numbers as strings of bits}
\begin{itemize}
	\item Evaluate:
	\item $n::=\$0|\$1|n 0|n 1|n + n$
	\item final configurations: numbers without "+", e.g. \$100101
	\item $ n\rightarrow n' $
	\item $\frac{n\rightarrow n'}{n0\rightarrow n'0}$
	\item $\frac{n\rightarrow n'}{n1\rightarrow n'1}$
	\item $\frac{m\rightarrow m'}{m+n\rightarrow m'+n}$
	\item $\frac{n\rightarrow n'}{m+n\rightarrow m+n'}$
	\item $\frac{}{m0+n0\rightarrow (m+n)0}$
	\item $\frac{}{m0+n1\rightarrow (m+n)1}$
	\item $\frac{}{m1+n0\rightarrow (m+n)1}$
	\item $\frac{}{m1+n1\rightarrow (m+n+\$1)0}$
	\item Fill in the last 4
	\item I think we should add a rule to merge two doll
\end{itemize}
\section{Next time}
Add to the syntax:
\begin{itemize}
	\item for x:=e to e do c 
	\item do e times c
	\item do c while e
\end{itemize}
\section{TODO przepisanie z zeszytu}
\section{Loop, continue and break}
$$C::=\ldots | loop\ c | continue | break$$
Last time we did small steps semantics using $c\ then\ d$ statements. Now we want big steps:
$$\frac{c,s\rightarrow\ldots}{loop\ c,s\rightarrow}\frac{}{continue,s\rightarrow}\frac{}{break,s\rightarrow\ldots}$$
We can change the set of configurations by adding to the existing set of final configurations pairs $(state, flag)$ where $flag\in \{CNT, BRK\}$, thus:
$$\frac{c,s\rightarrow s', loop\ c, s'\rightarrow s''}{loop\ c,s\rightarrow s''}
\frac{c,s\rightarrow (s', CNT), loop\ c, s'\rightarrow s''}{loop\ c,s\rightarrow s''}
\frac{c,s\rightarrow (s', BRK)}{loop\ c,s\rightarrow s'}$$
$$\frac{c,s\rightarrow s',(d,s')\rightarrow s'' }{c;d,s\rightarrow s''}, \hat s\in\{s'', (s'',CNT), (s'',BRK)\}
\frac{c,s\rightarrow (s', f)}{c;d,s\rightarrow (s', f)}
$$
\section{Expressions with side effects}
The syntax is as follows:
$$C::=Skip | x:=e | c;c$$$$e::=x|n|e+e|c\ resultis\ e$$
Old rules:
$$\frac{}{n,s\rightarrow \underline{n}}$$
$$\frac{}{x,s\rightarrow s(x)}$$
$$\frac{e,s\rightarrow \underline{m}\ \ f,s\rightarrow \underline{n}}{e+f,s\rightarrow \underline{\underline{m+n}}}$$
$$\frac{}{Skip,s\rightarrow s}$$
$$\frac{e,s\rightarrow \underline{n}}{x:=e,s\rightarrow s[x\mapsto n]}$$
New rules:
$$\frac{c,s\rightarrow s'\ \ e,s'\rightarrow \underline{n}}{c\ resultis\ e,s\rightarrow \underline{n}}$$
Buut, this doesn't propagate the state change from inside the expressions! To fix this, we change the meaning of $ \rightarrow $ for expressions by making it go to a pair $ (number, state)$. Here are the modified old rules for addition and $resultis$:
$$\frac{e,s\rightarrow \underline{m}, s'\ \ f,s\rightarrow \underline{n}, s''}{e+f,s\rightarrow \underline{\underline{m+n}}, s''}$$
$$\frac{c,s\rightarrow s'\ \ e,s'\rightarrow \underline{n}, s''}{c\ resultis\ e,s\rightarrow \underline{n}, s''}$$

\section{Let in expressions with lazy evaluation}
Previously we had 'call by value' semantics for let in expressions, now we want 'call by name' semantics, which evaluate the variable assignment only when its value is needed. In CBV, we had $\frac{}{s\vDash x\rightarrow s(x)}$. How do we write semantics for $ let $ in CBN?
$$\frac{s[x\mapsto e]\vDash f\rightarrow m}{s\vDash let\ x = e\ in\ f\rightarrow m}$$
$$\frac{s\vDash s(x)\rightarrow n}{s\vDash x\rightarrow \underline{n})}$$
But this is dynamic binding, the environment used is whatever was at the moment of evaluation.
To get static binding, we need variables to record state alongside the expressions: $ St=Var\rightarrow(Expr\times St)\cup \mathbb{Q} $. But this is not a definition, just a recursive equation! Thus, let $St_0=\emptyset$ and $ St_{i+1} = Var\rightarrow(E\times St_i \cup \mathbb{Q}) $. And the whole state is defined like this: (A set of russian dolls with arbitrary nesting) $ St=\bigcup_{i=0}^\infty St_i $.
Now we can get to the rules with static binding:
$$\frac{s(x)=(e,s')\ \ s'\vDash e\rightarrow n}{s\vDash x\rightarrow \underline{n}}$$
$$\frac{s[x\mapsto e, s]\vDash f\rightarrow m}{s\vDash let\ x = e\ in\ f\rightarrow m}$$

\section{Tutorial 14/11}
\subsection{Eager vs. lazy, dynamic vs. static}
\subsubsection{Higher order expression}
$$e::=x|n|e+e|let\ x=e\ in\ e | \lambda x.e|e\ e$$
Where $ \lambda x.e $ is $\lambda$ abstraction - function definition, and $e\ e$ is function application.
Now we find that the $let\ in$ construct is redundant. How do we express its semantics using $ \lambda $ abstraction and application?
$$let\ x = e\ in\ f \equiv (\lambda x.f) e$$
We need to use parentheses because application has the highest priority of all expressions.
\subsubsection{Call-by-value (eager) big step operational semantics.}
Is there a difference between static and dynamic binding in this case?
Without higher order expressions, we can't do dynamic binding, because we have no concept of expressions inside state. 
\paragraph{Is static = dynamic in higher order?}
$$let\ x=7\ in \ let \ f=\lambda y.y+x\ in\ let\ x=3\ in \ f\ 10$$
If we evaluate this expression with static binding, it evaluates to 17, as $ x $ gets mapped inside $ f $ to its value at the time of binding, and with dynamic binding it's 13, because $ x $ is bound to 3 at the time of application of $ f $.
To write the semantics, we introduce closure. For example, $ \lambda y.y+x $ in state $ s $ evaluates to the triplet called closure $ (y, y+x, s) \in Var\times Expr\times St$
\paragraph{Static binding with eager evaluation}
$$
\begin{matrix}
& \text{STATIC}& \text{DYNAMIC}\\
\text{EAGER}&
	\begin{matrix}
	Val=\mathbb{Z}\cup Var\times Expr\times St\\
	St=Var\rightarrow Val\\
	\text{mutually recursive}
	\end{matrix}&\\
\text{LAZY}&&
\end{matrix}
$$
Is it possible to construct sets that satisfy this recursive definition? We'll construct a family of sets for both $ Val $ and $ State $ and define them as infinite unions of all sequences.
$$
\begin{matrix}
Val_0=\emptyset & Val_{n+1}=\mathbb{Z}\cup Var\times Expr\times St_{n+1}\\
St_0=\emptyset  & St_{n+1}=Var\rightarrow Val_n\\
\end{matrix}
$$
Thus, $ Val_1=\mathbb{Z}, Val_2=\mathbb{Z}\cup Var\times Expr\times(Var\rightarrow \mathbb{Z})\ldots $
Now the big step semantics:
$$\frac{}{n,s\rightarrow n}\frac{}{x,s\rightarrow s(x)\in Val}
\frac{e,s\rightarrow\underline{m}, f,s\rightarrow \underline{n}}{e+f,s\rightarrow m+n}$$
And new ones:
$$\frac{}{\lambda x.e,s\rightarrow (x, e,s)},
\frac{(e, s)\rightarrow (x, e', s')\ (f, s) \rightarrow v\ (e', s'[x\mapsto v])\rightarrow v'}{e\ f,s\rightarrow v'}$$
Important: since elements of $Val$ can be either numbers or closures, then effects of our function applications can also be closures!
\paragraph{Dynamic binding with eager evaluation.}
$$
\begin{matrix}
& \text{STATIC}& \text{DYNAMIC}\\
	\text{EAGER} &
	\begin{matrix}
		Val=\mathbb{Z}\cup (Var\times Expr\times St)\\
		St=Var\rightarrow Val\\
		\text{mutually recursive}
	\end{matrix} &
	\begin{matrix}
		Val=\mathbb{Z}\cup (Var\times Expr)\\
		St=Var\rightarrow Val\\
		\text{not recursive anymore!}
	\end{matrix}\\
\text{LAZY}&&
\end{matrix}
$$
Now the rules:
$$\frac{}{\lambda x.e,s\rightarrow (x, e)},
\frac{(e, s)\rightarrow (x, e')\ (f, s) \rightarrow v\ (e', s[x\mapsto v])\rightarrow v'}{e\ f,s\rightarrow v'}$$
\paragraph{Static binding with lazy evaluation}
Is lazy (call by name) even different than eager (call by value)?
Suppose $ e $ is an expression that does not terminate.
Find $ f $ that uses $ e $ such that its lazy semantics are different than eager.
$$ (\lambda x.5)\ e $$
In lazy, the value is 5. In eager, it does not terminate.
This is an example of a side effect: not pure function.
$$
\begin{array}{c|c|c}
& \text{STATIC}& \text{DYNAMIC}\\\hline
	\text{EAGER} &
	\begin{matrix}
		Val=\mathbb{Z}\cup (Var\times Expr\times St)\\
		St=Var\rightarrow Val\\
		\text{mutually recursive}
	\end{matrix} &
	\begin{matrix}
		Val=\mathbb{Z}\cup (Var\times Expr)\\
		St=Var\rightarrow Val\\
		\text{not recursive anymore!}
	\end{matrix}\\\hline
\text{LAZY} &
	\begin{matrix}
		Val=\mathbb{Z}\cup (Var\times Expr\times St)\\
		St=Var\rightarrow (Expr \times St)\\
		\text{just state is recursive}
	\end{matrix} &
\end{array}
$$
Now the big step semantics:
$$\frac{}{n,s\rightarrow n}\frac{s(x)=(e,s')\ (e,s')\rightarrow v}{x,s\rightarrow v}
\frac{e,s\rightarrow\underline{m}, f,s\rightarrow \underline{n}}{e+f,s\rightarrow m+n}$$

$$\frac{}{\lambda x.e,s\rightarrow (x, e,s)},
\frac{e, s\rightarrow (x, e', s')\ , (e's'[x\mapsto (f,s)])\rightarrow v}{e\ f,s\rightarrow v}$$
We do not evaluate $ f $ anymore, we just pass it inside $ e' $!
\paragraph{Dynamic binding with lazy evaluation}
Example for a difference between static and dynamic under lazy evaluation:
$$(\lambda x(\lambda y\lambda x\ y)x\ 3)5$$
Under static we get 5, because $ y $ gets bound to expression $ x $, with the environment where $ x $ was bound to 5, while in static the expression $x$ gets evaluated in the internal environment where $ x $ is bound to 3.

$$
\begin{array}{c|c|c}
& \text{STATIC}& \text{DYNAMIC}\\\hline
\text{EAGER} &
	\begin{matrix}
		Val=\mathbb{Z}\cup (Var\times Expr\times St)\\
		St=Var\rightarrow Val\\
		\text{mutually recursive}
	\end{matrix} &
	\begin{matrix}
		Val=\mathbb{Z}\cup (Var\times Expr)\\
		St=Var\rightarrow Val\\
		\text{not recursive anymore!}
	\end{matrix}\\\hline
\text{LAZY} &
	\begin{matrix}
		Val=\mathbb{Z}\cup (Var\times Expr\times St)\\
		St=Var\rightarrow (Expr \times St)\\
		\text{just state is recursive}
	\end{matrix} &
	\begin{matrix}
		Val=\mathbb{Z}\cup (Var\times Expr)\\
		St=Var\rightarrow Expr\\
		\text{again, not recursive!}
	\end{matrix}
\end{array}
$$
And the rules:
$$
\frac{s(x)=e\ (e,s)\rightarrow v}{x,s\rightarrow v}
\frac{}{\lambda x.e,s\rightarrow (x, e)}$$$$
\frac{(e, s)\rightarrow (x, e')\ (e', s[x\mapsto f])\rightarrow v}{e\ f,s\rightarrow v}$$
\end{document}